
import os
import sys
import json
import logging
import re
import importlib
import random
import subprocess
import threading
if sys.version[0] == '2':
    import StringIO
else:
    import io as StringIO


##importdebugstart not use modules
import unittest
import tempfile
import disttools
##importdebugend not use modules

%EXTARGSPARSE_STRIP_CODE%

def write_file(s,outfile=None):
    fout = sys.stdout
    if outfile is not None:
        fout = open(outfile,'wb')
    bmode = False
    if 'b' in fout.mode:
        bmode = True
    if sys.version[0] == '2' or not bmode:
        fout.write('%s'%(s))
    else:
        fout.write(s.encode(encoding='UTF-8'))
    if fout != sys.stdout:
        fout.close()
    fout = None
    return

def read_file(infile=None):
    s = ''
    fin = sys.stdin
    if infile is not None:
        fin = open(infile,'rb')
    bmode = False
    if 'b' in fin.mode:
        bmode = True
    for l in fin:
        if sys.version[0] == '2' or not bmode:
            s += l
        else:
            s += l.decode(encoding='UTF-8')
    if fin != sys.stdin:
        fin.close()
    fin = None
    logging.info('[%s]s (%s)'%(infile,s))
    return s


def quote_string(s):
    rets = ''
    sb = 0
    for c in s:
        if c in [ '"']:
            if sb :
                rets += c
            else:
                rets += '\\'
                rets += c
            sb = 0
        elif c == '\\':
            sb = 1
            rets += '\\'
        else:
            sb = 0
            rets += c
    return rets


def __shell_out_list(argopts,args,keycls,keyname=None,defval=None):
    s = ''
    s += 'unset %s\n'%(keycls.varname)
    s += 'declare -a -g %s\n'%(keycls.varname)
    i = 0
    if keyname is None:
        keyname = keycls.optdest
    if defval is not None:
        for c in defval:
            s += '%s[%d]="%s"\n'%(keycls.varname,i,quote_string(c))
            i += 1            
    else:
        for c in getattr(args,keyname):
            s += '%s[%d]="%s"\n'%(keycls.varname,i,quote_string(c))
            i += 1
    return s

def __shell_output_command_inner(argopts,parser,args,cmdname=''):
    s = ''
    opts = parser.get_cmdopts(cmdname)
    if opts is not None:
        for opt in opts:
            if opt.type == 'args':
                if (args.subcommand is not None and (cmdname is not None and args.subcommand == cmdname) ) or \
                    (args.subcommand is None and ( cmdname is None or cmdname == '')):
                    keyname = opt.varname
                    defval = None
                    if args.subcommand is not None:
                        defval = args.subnargs
                    else:
                        defval =args.args
                    if keyname not in argopts.hasoutput:
                        s += __shell_out_list(argopts,args,opt,keyname,defval)
                        argopts.hasoutput.append(keyname)
                else:
                    keyname = opt.varname
                    if keyname != 'args' and keyname != 'subnargs' and keyname not in argopts.hasoutput:
                        s += __shell_out_list(argopts,args,opt,keyname,[])
                        argopts.hasoutput.append(keyname)
                continue
            elif opt.type == 'jsonfile' or opt.type == 'help':
                continue

            if opt.type == 'list':
                if opt.varname not in argopts.hasoutput:
                    s += __shell_out_list(argopts,args,opt)
                    argopts.hasoutput.append(opt.varname)
            elif opt.type == 'bool':
                if opt.varname not in argopts.hasoutput:
                    s += 'unset %s\n'%(opt.varname)
                    s += 'declare -g %s\n'%(opt.varname)
                    if getattr(args,opt.optdest,False):
                        s += '%s=1\n'%(opt.varname)
                    else:
                        s += '%s=0\n'%(opt.varname)
                    argopts.hasoutput.append(opt.varname)
            elif opt.type == 'string' or opt.type == 'unicode':
                if opt.varname not in argopts.hasoutput:
                    s += 'unset %s\n'%(opt.varname)
                    s += 'declare -g %s\n'%(opt.varname)
                    val = getattr(args,opt.optdest,None)
                    if val is not None:                    
                        s += '%s="%s"\n'%(opt.varname,quote_string(val))
                    else:
                        s += '%s=\n'%(opt.varname)
                    argopts.hasoutput.append(opt.varname)
            elif opt.type == 'long' or opt.type == 'int' or opt.type == 'count' :
                if opt.varname not in argopts.hasoutput:
                    s += 'unset %s\n'%(opt.varname)
                    s += 'declare -g %s\n'%(opt.varname)
                    val = getattr(args,opt.optdest,0)
                    s += '%s=%s\n'%(opt.varname,val)
                    argopts.hasoutput.append(opt.varname)
            elif opt.type == 'float':
                if opt.varname not in argopts.hasoutput:
                    s += 'unset %s\n'%(opt.varname)
                    s += 'declare -g %s\n'%(opt.varname)
                    val = getattr(args,opt.optdest,0.0)
                    s += '%s=%s\n'%(opt.varname,val)
                    argopts.hasoutput.append(opt.varname)
            else:
                logging.error('not known type (%s)'%(opt.type))
    return s

def __shell_output_command(argopts,parser,args,cmdname=''):
    s = ''
    subcmds = parser.get_subcommands(cmdname)
    if subcmds is not None:
        for c in subcmds:
            cname = '%s'%(cmdname)
            if len(cname) > 0:
                cname += '.'
            cname += c
            s += __shell_output_command(argopts,parser,args,cname)
    s += __shell_output_command_inner(argopts,parser,args,cmdname)
    return s


class OutputCollect(_LoggerObject):
    def __init__(self,output):
        super(OutputCollect,self).__init__()
        self.__output = output
        self.__input = []
        self.__thread =threading.Thread(target=self.input_handle,args=())
        self.__thread.start()
        return
    def __trans_to_string(self,s):
        if sys.version[0] == '3':
            encodetype = ['UTF-8','latin-1']
            idx=0
            while idx < len(encodetype):
                try:
                    return s.decode(encoding=encodetype[idx])
                except:
                    idx += 1
            raise Exception('not valid bytes (%s)'%(repr(s)))
        return s

    def input_handle(self):
        for line in iter(self.__output.readline, b''):
            transline = self.__trans_to_string(line)
            self.__input.append(transline)
        return


    def get_lines(self):
        if self.__thread is not None:
            self.__thread.join()
            self.__thread = None
            self.__output = None
        return self.__input

shell_env_string=''
shell_orig_env_string=''
shell_verbose_mode = 0
shell_bash_bin = '/bin/bash'
RANDOM_LOWER_CHARS = 'abcdefghijklmnopqrstuvwxyz'
RANDOM_UPPER_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
RANDOM_NUMBER_CHARS = '0123456789'
RANDOM_ALPHBET_CHARS = RANDOM_LOWER_CHARS + RANDOM_UPPER_CHARS
RANDOM_FUNC_CHARS = RANDOM_ALPHBET_CHARS + RANDOM_NUMBER_CHARS

def get_random_function_name(ins,number=10):
    while True:
        s = ''
        for i in range(number):
            if i > 0:
                s += random.choice(RANDOM_FUNC_CHARS)
            else:
                s += random.choice(RANDOM_ALPHBET_CHARS)
        chgs = ins.replace(s,'',0)
        if chgs == ins:
            return s
    return None

def format_tab_line(s,tabs=0):
    rets = ' ' * tabs * 4
    rets += '%s\n'%(s)
    return rets


def shell_function_callout(function_code,funcname):
    global shell_env_string
    global shell_bash_bin
    global shell_verbose_mode
    devnullfd = None
    if shell_verbose_mode < 3:
        devnullfd = open(os.devnull,'w')
    format_out_lines = 'shopt -s extglob\n%s\n'%(shell_env_string)
    logging.info('function_code (%s)'%(function_code))
    #logging.info('format_out_lines (%s)'%(format_out_lines))

    p = subprocess.Popen(shell_bash_bin,stdin=subprocess.PIPE,stdout=subprocess.PIPE,stderr=devnullfd,shell=False)  
    outhdl = OutputCollect(p.stdout)
    # now to give the environment
    if sys.version[0] == '2':
        p.stdin.write(format_out_lines)
        p.stdin.write(function_code)
        p.stdin.write('%s\n'%(funcname))
        p.stdin.write('declare\n')
    else:
        p.stdin.write(bytes(format_out_lines,'UTF-8'))
        p.stdin.write(bytes(function_code,'UTF-8'))
        p.stdin.write(bytes('%s\n'%(funcname),'UTF-8'))
        p.stdin.write(bytes('declare\n','UTF-8'))
    p.stdin.close()
    # we get lines
    retlines = outhdl.get_lines()
    outhdl = None
    if devnullfd is not None:
        devnullfd.close()
    devnullfd = None
    return retlines

def shell_get_value(retlines,keycls,getnumber):
    global shell_env_string
    idx = 0
    numret = 0
    intexpr = re.compile('^(\d+)$')
    listexpr = re.compile('%s\[([\d]+)\]=(.*)'%(keycls.varname))
    intvarexpr = re.compile('%s=([\d]+)'%(keycls.varname))
    floatvarexpr = re.compile('%s=([\d]+(\.[\d]+)?)'%(keycls.varname))
    boolvarexpr = re.compile('%s=([01])'%(keycls.varname))
    strvarexpr = re.compile('%s=(.*)'%(keycls.varname))
    envstarted = 0
    argsvalue = None
    if keycls.type == 'list':
        argsvalue = []
    for l in retlines:  
        idx += 1
        if idx == 1 and getnumber :
            logging.info('l [%s]'%(l.rstrip('\r\n')))
            if intexpr.match(l.rstrip('\r\n')):
                numret = int(l.rstrip('\r\n'))
            elif l.rstrip('\r\n') == 'error':
                raise Exception('get error')
        elif envstarted == 0 and l.rstrip('\r\n') == '':
            shell_env_string = ''
            envstarted = 1
        elif envstarted == 0 and l.rstrip('\r\n') == 'error':
            raise Exception('get error')
        elif envstarted == 0:
            # it is the value one
            startename = '%s'%(keycls.varname)
            if l.startswith(startename):
                if keycls.type == 'list':
                    m = listexpr.findall(l.rstrip('\r\n'))
                    if m is not None and len(m) > 0 and len(m[0]) == 2:
                        listidx = int(m[0][0])
                        v = m[0][1]
                        if listidx == len(argsvalue):
                            argsvalue.append(v)
                        else:
                            logging.warn('[%s] not valid name'%(l.rstrip('\r\n')))
                    else:
                        logging.warn('[%s] not valid for list'%(l.rstrip('\r\n')))
                elif keycls.type == 'string' or (keycls.type == 'unicode' and sys.version[0] == '2'):
                    m = strvarexpr.findall(l.rstrip('\r\n'))
                    if m is not None and argsvalue is None:
                        argsvalue = m[0]
                    else:
                        logging.warn('[%s] not valid for string'%(l.rstrip('\r\n')))
                elif keycls.type == 'count' or keycls.type == 'int' or keycls.type == 'long':
                    m = intvarexpr.findall(l.rstrip('\r\n'))
                    if m is not None and argsvalue is None:
                        argsvalue = int(m[0])
                    else:
                        logging.warn('[%s] not valid for %s'%(l.rstrip('\r\n'),keycls.type))
                elif keycls.type == 'float':
                    m = floatvarexpr.findall(l.rstrip('\r\n'))
                    if m is not None and len(m[0]) > 0 and argsvalue is None:
                        argsvalue = float(m[0][0])
                    else:
                        logging.warn('[%s] not valid for %s'%(l.rstrip('\r\n'),keycls.type))
                elif keycls.type == 'bool':
                    m = boolvarexpr.findall(l.rstrip('\r\n'))
                    if m is not None and len(m) > 0 and argsvalue is None:
                        if int(m[0]) > 0:
                            argsvalue = True
                        else:
                            argsvalue = False
                    else:
                        logging.warn('[%s] not valid for %s'%(l.rstrip('\r\n'),keycls.type))
                else:
                    logging.warn('unknown type [%s]'%(keycls.type))

        else:
            # that is the shell options
            shell_env_string += l
    logging.info('numret [%s] argsvalue(%s)'%(numret,argsvalue))
    return numret,argsvalue

def format_function_code(callstr,keycls,args=None):
    funcname = get_random_function_name(shell_env_string)
    function_code = ''
    function_code += format_tab_line('%s()'%(funcname))
    function_code += format_tab_line('{')
    if args is not None:
        if keycls.type == 'list':
            function_code += format_tab_line('local _idx',1)
            function_code += format_tab_line('local _curelm',1)
        if keycls.type == 'list':
            function_code += format_tab_line('unset %s'%(keycls.varname),1)
            function_code += format_tab_line('declare -g -a %s'%(keycls.varname),1)
            logging.info('keycls.optdest [%s]'%(keycls.varname))
            value = getattr(args,keycls.optdest,None)
            if value is not None:
                idx = 0
                for c in value:
                    function_code += format_tab_line('%s[%d]=%s'%(keycls.varname,idx,c),1)
                    idx += 1
        else:
            function_code += format_tab_line('unset %s'%(keycls.varname),1)
            function_code += format_tab_line('declare -g %s'%(keycls.varname),1)
            if keycls.type == 'bool':
                value = getattr(args,keycls.optdest,None)
                if value is not None:
                    if value:
                        function_code += format_tab_line('%s=1'%(keycls.varname),1)
                    else:
                        function_code += format_tab_line('%s=0'%(keycls.varname),1)
            elif keycls.type == 'string':
                value = getattr(args,keycls.optdest,None)
                if value is not None:
                    function_code += format_tab_line('%s="%s"'%(keycls.varname,quote_string(value)),1)
            elif keycls.type == 'int' or keycls.type == 'count' or keycls.type == 'float':
                value = getattr(args,keycls.optdest,None)
                if value is not None:
                    function_code += format_tab_line('%s=%s'%(keycls.varname,value),1)
    function_code += format_tab_line('',1)
    function_code += format_tab_line('EXTARGSPARSE4SH_LONGOPT="%s"'%(keycls.longopt),1)
    if keycls.shortopt is not None:
        function_code += format_tab_line('EXTARGSPARSE4SH_SHORTOPT="%s"'%(keycls.shortopt),1)
    else:
        function_code += format_tab_line('EXTARGSPARSE4SH_SHORTOPT=',1)
    function_code += format_tab_line('EXTARGSPARSE4SH_VARNAME="%s"'%(keycls.varname),1)

    function_code += format_tab_line(callstr,1)

    # now we should make sure the test case
    if args is not None:
        if keycls.type == 'list':
            function_code += format_tab_line('_idx=0',1)
            function_code += format_tab_line('for _curelm in "${%s[@]}"'%(keycls.varname),1)
            function_code += format_tab_line('do',1)
            function_code += format_tab_line('echo "%s[$_idx]=$_curelm"'%(keycls.varname),2)
            function_code += format_tab_line('_idx=`expr $_idx \+ 1`',2)
            function_code += format_tab_line('done',1)
        else:
            function_code += format_tab_line('echo "%s=$%s"'%(keycls.varname,keycls.varname),1)
    function_code += format_tab_line('echo ""',1)
    function_code += format_tab_line('return',1)
    function_code += format_tab_line('}',0)
    return function_code,funcname

def shell_optparse(args,validx,keycls,params):
    global shell_env_string
    global shell_verbose_mode
    global shell_bash_bin
    if keycls.attr is None or keycls.attr.shellfunc is None:
        # this is the 
        return 0
    callstr = '%s "%s"'%(keycls.attr.shellfunc,validx)
    for c in params:
        callstr += ' "%s"'%(quote_string(c))
    function_code , funcname = format_function_code(callstr,keycls,args)
    logging.info('function_code (%s)'%(function_code))
    retlines = shell_function_callout(function_code,funcname)
    numret,argsvalue = shell_get_value(retlines,keycls,True)
    setattr(args,keycls.optdest,argsvalue)
    return numret

def shell_helpfunc(keycls):
    global shell_env_string
    if keycls.attr is None or keycls.attr.shell_opthelp is None:
        return ''
    callstr = '%s'%(keycls.attr.shell_opthelp)
    function_code , funcname = format_function_code(callstr,keycls,None)
    logging.info('function_code (%s)'%(function_code))
    retlines = shell_function_callout(function_code,funcname)
    helpinfo = ''
    envstarted = 0
    for l in retlines:
        if envstarted == 0:
            if l.rstrip('\r\n') == '':
                envstarted = 1
                shell_env_string = ''
            else:
                helpinfo += l.rstrip('\r\n')
        else:
            shell_env_string += l
    return helpinfo


def shell_jsonfunc(args,keycls,value):
    global shell_verbose_mode
    global shell_env_string
    global shell_bash_bin
    if keycls.attr is None or keycls.attr.shell_jsonfunc is None:
        return
    callstr = '%s '%(keycls.attr.shell_jsonfunc)
    idx = 0
    if keycls.type == 'string' or keycls.type == 'unicode':
        if value is not None:
            callstr += '"%s"'%(quote_string(value))
    elif keycls.type == 'float' or keycls.type == 'int' or keycls.type == 'long' or keycls.type == 'count':
        if value is not None:
            callstr += '%s'%(value)
    elif keycls.type == 'bool':
        if value is not None:
            if value :
                callstr += '1'
            else:
                callstr += '0'
    elif keycls.type == 'list':
        if value is not None:            
            for c in value:
                callstr += ' '
                callstr += '"%s"'%(quote_string(c))
    elif keycls.type == 'jsonfile':
        if value is not None:
            callstr += '"%s"'%(quote_string(value))
    else:
        raise Exception('[%s] not supported type'%(keycls.type))
    function_code , funcname = format_function_code(callstr,keycls,args)
    logging.info('function_code (%s)'%(function_code))
    retlines = shell_function_callout(function_code,funcname)
    numret,argsvalue = shell_get_value(retlines,keycls,False)
    setattr(args,keycls.optdest,argsvalue)
    return


def get_decl_string(l):
    s = ''
    if l is not None and len(l) > 0:
        if l[0] == r'%':
            firstdollar = 0
            secdollar = -1
            idx = 1
            while idx < len(l):
                if l[idx] == r'%':
                    secdollar = idx
                    break
                idx += 1
            if secdollar > 0:
                repls = l[:(secdollar+1)]
                s = l.replace(repls,'\n')
    return s



def bash_output(argopts,parser,args):
    s = ''
    argopts.hasoutput= []
    if args.subcommand is not None and len(args.subcommand) > 0:
        keycls = parser.get_cmdkey(args.subcommand)
        if keycls.function is not None:
            s += 'unset %s\n'%(keycls.function)
            s += 'declare -g %s\n'%(keycls.function)
            s += '%s=%s\n'%(keycls.function,args.subcommand)
            argopts.hasoutput.append(keycls.function)
        # to declare the subcommand ok
        sarr = re.split('\.',args.subcommand)
        i = len(sarr)
        while i > 0:
            # to give the command line
            newname = '.'.join(sarr[:i])
            s += __shell_output_command_inner(argopts,parser,args,newname)
            i -= 1
    s +=  __shell_output_command(argopts,parser,args)
    logging.info('output (%s)'%(s))
    return s

def get_replace_string(l):
    i = 0
    newname = get_random_function_name(l)
    return '%%%s%%'%(newname) +  l.replace('\n','%%%s%%'%(newname))

def __set_optparse_function(argsopt,parser,cmdname=None):
    if cmdname is None:
        cmdname = ''
    s = ''
    opts = parser.get_cmdopts(cmdname)
    if opts is not None:
        for opt in opts:
            logging.info('[%s] opt[%s]'%(cmdname,opt))
            if not opt.isflag or opt.type == 'args' or \
                opt.type == 'jsonfile' or opt.type == 'help' :
                continue
            if opt.attr is not None and opt.attr.optparse is not None:
                if opt.attr.shellfunc is None:
                    logging.info('set [%s] for shell_optparse'%(opt.optdest))
                    opt.attr.shellfunc = opt.attr.optparse
                    opt.attr.optparse = 'shell_optparse'

            if opt.attr is not None and opt.attr.opthelp is not None:
                if opt.attr.shell_opthelp is None:
                    logging.info('set [%s] for shell_opthelp'%(opt.optdest))
                    opt.attr.shell_opthelp = opt.attr.opthelp
                    opt.attr.opthelp = 'shell_opthelp'

            if opt.attr is not None and opt.attr.jsonfunc is not None:
                if opt.attr.shell_jsonfunc is None:
                    logging.info('set [%s] for shell_jsonfunc'%(opt.optdest))
                    opt.attr.shell_jsonfunc = opt.attr.jsonfunc
                    opt.attr.jsonfunc = 'shell_jsonfunc'

    subcmds = parser.get_subcommands(cmdname)
    if subcmds is not None:
        for c in subcmds:
            cname = '%s'%(cmdname)
            if len(cname) > 0:
                cname += '.'
            cname += c
            __set_optparse_function(argsopt,parser,cname)
    return


def set_optparse_function(argsopt,parser):
    __set_optparse_function(argsopt,parser)
    return

def get_full_trace_back(trback,tabs=1,cnt=0):
    s = ''
    frm = getattr(trback,'tb_frame',None)
    if frm is not None:
        code = getattr(frm,'f_code',None)
        if code is not None:
            s += ' ' * tabs * 4
            s += '[%d][%s:%s:%s]\n'%(cnt,code.co_filename,code.co_name,frm.f_lineno)
            ntrace = getattr(trback,'tb_next',None)
            if ntrace is not None:
                s += get_full_trace_back(ntrace,tabs,cnt+1)
    return s

def get_exc_info():
    trback = sys.exc_info()[2]
    exceptname = sys.exc_info()[1]
    s = ''
    s += 'exception %s:\n'%(exceptname)
    s +='trace back:\n'
    s += get_full_trace_back(trback,1,0)
    return s

def format_bash_output(argsopt,options,params=None,extoptionstr=None):
    s = ''
    try:
        priority=  None
        extdict = None
        if extoptionstr is not None:
            try:
                extdict = json.loads(extoptionstr)
                if 'priority' in extdict.keys() and isinstance(extdict['priority'],list):
                    priority = []
                    for c in extdict['priority']:
                        if c == 'SUBCMD_JSON':
                            priority.append(SUB_COMMAND_JSON_SET)
                        elif c == 'CMD_JSON':
                            priority.append(COMMAND_JSON_SET)
                        elif c == 'ENV_SUBCMD_JSON':
                            priority.append(ENV_SUB_COMMAND_JSON_SET)
                        elif c == 'ENV_CMD_JSON':
                            priority.append(ENV_COMMAND_JSON_SET)
                        elif c == 'ENV_CMD':
                            priority.append(ENVIRONMENT_SET)
                        else:
                            logging.error('not recognize priority [%s]'%(c))
                    del extdict['priority']
            except:
                extdict = None
                pass
        extoptions = ExtArgsOptions(extdict)
        extoptions.prog = argsopt.caption
        parser = ExtArgsParse(extoptions,priority)
        parser.load_command_line_string(options)
        logging.info('before set parser')
        set_optparse_function(argsopt,parser)
        logging.info('get set parser')
        args = parser.parse_command_line(params,parser,'bash')
        s += bash_output(argsopt,parser,args)
    except:
        s = 'cat <<EOFMM\n'
        exc_type, exc_value, exc_traceback = sys.exc_info()
        s += 'cat <<EOM\n%s:%s:%s\n%sEOM\n'%(exc_type,exc_value,exc_traceback,get_exc_info())
        s += 'EOFMM\n'
        s += 'exit 3;\n'
    return s

class debug_shellouttest_cases(unittest.TestCase):
    def setUp(self):
        keyname = '_%s__logger'%(self.__class__.__name__)
        if getattr(self,keyname,None) is None:
            self.__logger = _LoggerObject()
            self.info('create logger')

        delone = True
        while delone:
            delone = False
            for k in os.environ.keys():
                if k.startswith('EXTARGS_') or k.startswith('DEP_') or k == 'EXTARGSPARSE_' or k.startswith('RDEP_'):
                    del os.environ[k]
                    delone = True
                    break
        return

    def info(self,msg,callstack=1):
        return self.__logger.info(msg,(callstack + 1))

    def error(self,msg,callstack=1):
        return self.__logger.error(msg,(callstack + 1))

    def warn(self,msg,callstack=1):
        return self.__logger.warn(msg,(callstack + 1))

    def debug(self,msg,callstack=1):
        return self.__logger.debug(msg,(callstack + 1))

    def fatal(self,msg,callstack=1):
        return self.__logger.fatal(msg,(callstack + 1))

    def tearDown(self):
        pass

    @classmethod
    def setUpClass(cls):
        pass

    @classmethod
    def tearDownClass(cls):
        pass


    def __has_line(self,sarr,s):
        ok = False
        for nl in sarr:
            l = nl.rstrip('\r\n')
            if s == l:
                ok = True
                break
        return ok

    def __line_prefix(self,sarr,s):
        ok = False
        for nl in sarr:
            l = nl.rstrip('\r\n')
            if l.startswith(s):
                ok = True
                break
        return ok

    def __get_argsopt(self):
        argsopt = NameSpaceEx()
        argsopt.caption = 'extargsparse4sh_test'
        return argsopt

    def __get_bash_output(self,options,params):
        argsopt = self.__get_argsopt()
        s = format_bash_output(argsopt,options,params)
        return s


    def __check_value_common(self,s,key,value):
        sarr = re.split('\n',s)
        ok = self.__has_line(sarr,'unset %s'%(key))
        self.assertEqual(ok,True)
        ok = self.__has_line(sarr,'declare -g %s'%(key))
        self.assertEqual(ok,True)
        ok = self.__has_line(sarr,'%s=%s'%(key,value))
        self.assertEqual(ok,True)
        return
    

    def __check_value_list(self,s,key,value):
        sarr = re.split('\n',s)
        ok = self.__has_line(sarr,'declare -a -g %s'%(key))
        self.assertEqual(ok,True)
        ok = self.__has_line(sarr,'unset %s'%(key))
        self.assertEqual(ok,True)
        if len(value) == 0:
            # now we should get the 
            ok = self.__line_prefix(sarr,'%s[%d]='%(key,0))
            self.assertEqual(ok,False)
        else:
            i = 0
            for v in value:
                ok = self.__has_line(sarr,'%s[%d]="%s"'%(key,i,quote_string(v)))
                self.assertEqual(ok,True)
                i += 1
            ok = self.__line_prefix(sarr,'%s[%d]='%(key,i))
            self.assertEqual(ok,False)
        return

    def __check_not_list(self,s,key):
        sarr = re.split('\n',s)
        ok = self.__has_line(sarr,'delcare -a %s'%(key))
        self.assertEqual(ok,False)
        return

    def __check_not_common(self,s,key):
        sarr = re.split('\n',s)
        ok = self.__line_prefix(sarr,'%s='%(key))
        self.assertEqual(ok,False)
        return

    def test_A001(self):
        commandline= '''
        {
            "verbose|v" : "+",
            "port|p" : 3000
        }
        '''
        s = self.__get_bash_output(options=commandline,params=['-vvvv','-p','5000'])
        self.info('get (%s)'%(s))
        self.__check_value_common(s,'port',5000)
        self.__check_value_common(s,'verbose',4)
        self.__check_value_list(s,'args',[])
        self.__check_not_list(s,'subnargs')
        self.__check_not_common(s,'subcommand')
        self.__check_not_common(s,'json')
        return

    def test_A002(self):
        commandline='''
        {
            "$verbose|v<verbosemode>" : "+",
            "port|p<portnum>" : 7000
        }
        '''
        s = self.__get_bash_output(options=commandline,params=['-vvvv','-p','5000'])
        self.__check_value_common(s,'portnum',5000)
        self.__check_value_common(s,'verbosemode',4)
        self.__check_value_list(s,'args',[])
        self.__check_not_common(s,'json')
        return

    def test_A003(self):
        commandline='''
        {
            "$verbose|v<verbosemode>" : "+",
            "port|p<portnum>" : 7000,
            "dep" : {
                "http" : true,
                "age"  : 50,
                "$" : "+"
            }
        }
        '''
        s = self.__get_bash_output(options=commandline,params=['-vvvv','-p','5000','dep','cc','dd'])
        self.__check_value_common(s,'portnum',5000)
        self.__check_value_common(s,'verbosemode',4)
        self.__check_value_common(s,'dep_http',1)
        self.__check_value_common(s,'dep_age',50)
        self.__check_value_list(s,'subnargs',['cc','dd'])
        self.__check_not_common(s,'json')
        self.__check_not_common(s,'dep_json')
        return

    def test_A004(self):
        commandline='''
        {
            "$verbose|v<verbosemode>" : "+",
            "port|p<portnum>" : 7000,
            "dep<CHOICECOMMAND>" : {
                "http" : true,
                "age"  : 50,
                "$<depargs>" : "+"
            }
        }
        '''
        s = self.__get_bash_output(options=commandline,params=['-vvvv','-p','5000','dep','cc','dd'])
        self.__check_value_common(s,'portnum',5000)
        self.__check_value_common(s,'verbosemode',4)
        self.__check_value_common(s,'dep_http',1)
        self.__check_value_common(s,'dep_age',50)
        self.__check_value_list(s,'depargs',['cc','dd'])
        self.__check_not_common(s,'json')
        self.__check_not_common(s,'dep_json')
        return

    def test_A005(self):
        commandline='''
        {
            "$verbose|v<verbosemode>" : "+",
            "port|p<portnum>" : 7000,
            "dep<CHOICECOMMAND>" : {
                "http" : true,
                "age"  : 50,
                "$<depargs>" : "+"
            },
            "rdep<CHOICECOMMAND>" : {
                "http" : true,
                "age" : 48,
                "$<rdepargs>" : "+"
            }
        }
        '''
        s = self.__get_bash_output(options=commandline,params=['-vvvv','-p','5000','dep','cc','dd'])
        self.__check_value_common(s,'portnum',5000)
        self.__check_value_common(s,'verbosemode',4)
        self.__check_value_common(s,'dep_http',1)
        self.__check_value_common(s,'dep_age',50)
        self.__check_value_list(s,'depargs',['cc','dd'])
        self.__check_value_list(s,'rdepargs',[])
        self.__check_value_common(s,'rdep_http',1)
        self.__check_value_common(s,'rdep_age',48)
        self.__check_value_common(s,'CHOICECOMMAND','dep')
        self.__check_not_common(s,'json')
        self.__check_not_common(s,'dep_json')
        self.__check_not_common(s,'rdep_json')
        return


    def test_A006(self):
        commandline='''
        {
            "$verbose|v<verbosemode>" : "+",
            "port|p<portnum>" : 7000,
            "dep<CHOICECOMMAND>" : {
                "http" : true,
                "age"  : 50,
                "$<depargs>" : "+"
            },
            "rdep<CHOICECOMMAND>" : {
                "http" : true,
                "age" : 48,
                "$<rdepargs>" : "+"
            }
        }
        '''
        s = self.__get_bash_output(options=commandline,params=['-vvvv','-p','5000','dep','cc ee','dd'])
        self.__check_value_common(s,'portnum',5000)
        self.__check_value_common(s,'verbosemode',4)
        self.__check_value_common(s,'dep_http',1)
        self.__check_value_common(s,'dep_age',50)
        self.__check_value_list(s,'depargs',['cc ee','dd'])
        self.__check_value_list(s,'rdepargs',[])
        self.__check_value_common(s,'rdep_http',1)
        self.__check_value_common(s,'rdep_age',48)
        self.__check_not_common(s,'json')
        self.__check_not_common(s,'dep_json')
        self.__check_not_common(s,'rdep_json')
        return

    def test_A007(self):
        commandline='''
        {
            "$verbose|v<verbosemode>" : "+",
            "port|p<portnum>" : 7000,
            "dep<CHOICECOMMAND>" : {
                "http" : true,
                "age"  : 50,
                "$<depargs>" : "+"
            },
            "rdep<CHOICECOMMAND>" : {
                "http" : true,
                "age" : 48,
                "$<rdepargs>" : "+"
            }
        }
        '''
        s = self.__get_bash_output(options=commandline,params=['-vvvv','-p','5000','dep','cc ee','\'dd\'','"ff cc"'])
        self.__check_value_common(s,'portnum',5000)
        self.__check_value_common(s,'verbosemode',4)
        self.__check_value_common(s,'dep_http',1)
        self.__check_value_common(s,'dep_age',50)
        self.__check_value_list(s,'depargs',['cc ee','\'dd\'','"ff cc"'])
        self.__check_value_list(s,'rdepargs',[])
        self.__check_value_common(s,'rdep_http',1)
        self.__check_value_common(s,'rdep_age',48)
        self.__check_value_common(s,'CHOICECOMMAND','dep')
        self.__check_not_common(s,'json')
        self.__check_not_common(s,'dep_json')
        self.__check_not_common(s,'rdep_json')
        return

    def test_A008(self):
        commandline='''
        {
            "$verbose|v<verbosemode>" : "+",
            "port|p<portnum>" : 7000,
            "dep<CHOICECOMMAND>" : {
                "http" : true,
                "age"  : 50,
                "$<packages>" : "+"
            },
            "rdep<CHOICECOMMAND>" : {
                "http" : true,
                "age" : 48,
                "$<packages>" : "+"
            }
        }
        '''
        s = self.__get_bash_output(options=commandline,params=['-vvvv','-p','5000','dep','cc ee','\'dd\'','"ff cc"'])
        self.__check_value_common(s,'portnum',5000)
        self.__check_value_common(s,'verbosemode',4)
        self.__check_value_common(s,'dep_http',1)
        self.__check_value_common(s,'dep_age',50)
        self.__check_value_list(s,'packages',['cc ee','\'dd\'','"ff cc"'])
        self.__check_value_common(s,'rdep_http',1)
        self.__check_value_common(s,'rdep_age',48)
        self.__check_value_common(s,'CHOICECOMMAND','dep')
        self.__check_not_common(s,'json')
        self.__check_not_common(s,'dep_json')
        self.__check_not_common(s,'rdep_json')
        return


    def test_A009(self):
        commandline='''
        {
            "$verbose|v<verbosemode>" : "+",
            "port|p<portnum>" : 7000,
            "dep<CHOICECOMMAND>" : {
                "http" : true,
                "age"  : 50,
                "$<packages>" : "+"
            },
            "rdep<CHOICECOMMAND>" : {
                "http" : true,
                "age" : 48,
                "$<packages>" : "+"
            }
        }
        '''
        s = self.__get_bash_output(options=commandline,params=['-vvvv','-p','5000','rdep','cc ee','\'dd\'','"ff cc"'])
        self.__check_value_common(s,'portnum',5000)
        self.__check_value_common(s,'verbosemode',4)
        self.__check_value_common(s,'dep_http',1)
        self.__check_value_common(s,'dep_age',50)
        self.__check_value_list(s,'packages',['cc ee','\'dd\'','"ff cc"'])
        self.__check_value_common(s,'rdep_http',1)
        self.__check_value_common(s,'rdep_age',48)
        self.__check_value_common(s,'CHOICECOMMAND','rdep')
        self.__check_not_common(s,'json')
        self.__check_not_common(s,'dep_json')
        self.__check_not_common(s,'rdep_json')
        return

    def test_A010(self):
        commandline='''
        {
            "fdisk<CHOICECOMMAND>" : {
                "$<packages>##to specify packages additional installed##" : "*"
            },
            "debootstrap<CHOICECOMMAND>" : {
                "$<packages>##to specify packages additional installed##" : "*"
            },
            "mountalldir<CHOICECOMMAND>" : {
                "$<packages>##to specify packages additional installed##" : "*"
            },
            "$<packages>##to specify packages additional installed##" : "*"
        }
        '''
        s = self.__get_bash_output(options=commandline,params=['debootstrap','hello','ok'])
        self.__check_value_common(s,'CHOICECOMMAND','debootstrap')
        self.__check_value_list(s,'packages',['hello','ok'])
        return

def set_log_level(args):
    loglvl= logging.ERROR
    if args.verbose >= 3:
        loglvl = logging.DEBUG
    elif args.verbose >= 2:
        loglvl = logging.INFO
    elif args.verbose >= 1 :
        loglvl = logging.WARN
    # we delete old handlers ,and set new handler
    if logging.root is not None and len(logging.root.handlers) > 0:
        logging.root.handlers = []
    logging.basicConfig(level=loglvl,format='%(asctime)s:%(filename)s:%(funcName)s:%(lineno)d\t%(message)s')
    return

def reset_extargs_logger(args):
    os.environ['EXTARGSPARSE_LOGLEVEL']  = '%d'%(args.verbose)
    logger = logging.getLogger('extargsparse')
    logger.handlers = []
    return

def parse_inner(args):
    global shell_env_string
    global shell_orig_env_string
    reset_extargs_logger(args)
    commandline = ''
    commandline += read_file(args.input)
    i=0
    for a in args.subnargs:
        logging.info('subnargs[%d]=%s'%(i,a))
        i += 1        
    outs = format_bash_output(args,options=commandline,params=args.subnargs,extoptionstr=args.options)
    s = ''
    if shell_env_string != shell_orig_env_string:
        s += 'shopt -s extglob\n'%()
        s += shell_env_string
    s += '\n'    
    s += outs
    sys.stdout.write('%s'%(s))
    logging.info('out (%s)'%(s))
    return

def cmd_change_test(args):
    reset_extargs_logger(args)
    sys.argv[1:]=args.subnargs
    unittest.main(verbosity=args.verbose,failfast=args.failfast)
    return



def cmd_change_release(args):
    excludes=[r'^debug_.*']
    macros = [[r'^##importdebugstart.*',r'^##importdebugend.*']]
    cmdchanges=[r'cmd_change_.*']
    repls = dict()
    disttools.release_file('__main__',None,excludes,macros,cmdchanges,repls,None,None)
    return

def test_handler(args,parser):
    set_log_level(args)
    cmd_change_test(args)
    sys.exit(0)
    return

def release_handler(args,parser):
    set_log_level(args)
    cmd_change_release(args)
    sys.exit(0)
    return

def parse_handler(args,parser):
    global shell_env_string
    global shell_verbose_mode
    global shell_bash_bin
    global shell_orig_env_string
    set_log_level(args)
    if args.declfile is not None:
        shell_env_string = get_decl_string(read_file(args.declfile))
    else:
        shell_env_string = get_decl_string(args.declstr)
    logging.info('declstr (%s)'%(len(shell_env_string)))
    shell_orig_env_string = shell_env_string
    shell_verbose_mode = args.verbose
    shell_bash_bin = args.bash
    if args.catch:
        try:
            parse_inner(args)
        except Exception as e:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            frame = sys._getframe(1)
            debuginfo = '[%-10s:%-20s:%-5s] '%(frame.f_code.co_filename,frame.f_code.co_name,frame.f_lineno)
            sys.stdout.write('cat <<EOM\n%s\t %s:%s:%s\nEOM\n'%(debuginfo,exc_type,exc_value,exc_traceback))
            sys.stdout.write('exit 3')
            sys.exit(3)
    else:
        parse_inner(args)
    sys.exit(0)
    return

def declare_handler(args,parser):
    set_log_level(args)
    outs = ''
    outs = get_replace_string(read_file(args.input))
    logging.info('outs (%s)'%(outs))
    write_file(outs,args.output)
    sys.exit(0)
    return

def main():
    inner_command='''
    {
        "verbose|v" : "+",
        "catch|C## to not catch the exception ##" : true,
        "input|i## to specify input default(stdin)##" : null,
        "output|o## to sepcify outpu default(stdout)##" : null,
        "$caption## set caption ##" : "runcommand",
        "release|R## to release test mode##" : false,
        "priority|P## set priority##" : [],
        "failfast|f" : false,
        "bash|b" : "/bin/bash",
        "options|O## set options##"  : null,
        "declstr|d## declare string of environ##" : "",
        "declfile## declare file of environ##" : null,
        "parse<parse_handler>" : {
            "$" : "*"
        },
        "test<test_handler>" : {
            "$" : "*"
        },
        "release<release_handler>" : {
            "$" : "*"
        },
        "declare<declare_handler>" : {
            "$" : 0
        }
    }
    '''
    parser = ExtArgsParse(None,priority=[])
    parser.load_command_line_string(inner_command)
    args = parser.parse_command_line(None)
    raise Exception('[%s] not supported subcommand'%(args.subcommand))
    return

if __name__ == '__main__':
    main()
